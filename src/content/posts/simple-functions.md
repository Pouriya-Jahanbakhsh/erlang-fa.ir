+++
title = "Simple Functions"
date = "2019-06-21T00:00:08"
+++

در بخش قبلی تا حدودی با پترن مچینگ آشنا شدیم. در این قسمت قرار بر این شد تا کد زدن در فایل و کامپایل و اجرا کردنش رو یاد بگیریم.  
در ارلنگ فایل هایی که حاوی کد های ارلنگ هستند رو با پسوند erl نام گذاری میکنیم. برای مثال نام های زیر برای فایل های حاوی کد ارلنگ درست هستند:

{{< highlight sh >}}
foo.erl
foo_bar.erl
foo_bar_2.erl
{{< / highlight >}}

البته اسمی مثل fOoBaRbAz.erl هم درسته ولی بهتره فقط از حروف کوچک انگلیسی و اعداد و کاراکتر _ استفاده کنید. چرا که این یک استاندارد هست و حفظ استاندارد باعث میشه کد هاتون توسط بقیه ی ارلنگ کار ها راحت تر خونده بشه و اگر از استاندارد خارج بشید ممکنه نتونید از بعضی از ابزار هایی که برای کد های استاندارد توسعه داده شدن استفاده کنید !




## Atom ساختمان داده
توجه کردید که اسم فایل ها با حروف کوچک انگلیسی شروع شدند؟ توجه کردید که نام متغیر ها با حروف بزرگ انگلیسی شروع میشدند؟ خوب این اتفاقی نیست. ساختمان داده اتم در ارلنگ با حروف کوچک انگلیسی شروع میشه و میتونه حاوی حروف کوچک و یا بزرگ انگلیسی و اعداد و کاراکتر های @ و _ باشه.

{{< highlight erlang >}}
1> atom.
atom

2> another_atom.
another_atom

3> Var = foo_1.
foo_1

4> Var.
foo_1
{{< / highlight >}}

خوب این اتم ها اصلا چی هستن و چه خصوصیاتی دارن؟ اگر بخوام در یک جمله اتم هارو تعریف کنم میگم اتم ها خودشون هستند. نه بیشتر و نه کمتر. اتم ها قابلیت جمع  یا ضرب و یا تفریق و تقسیم با هم رو ندارند. مقداری درشون ذخیره نشده اما میتونن به عنوان مقدار استفاده بشن. نمیتونید به کاراکتر n ام اتم ها دسترسی پیدا کنید (مثل رشته ها) و ... .  
در این فصل خواهیم دید که اتم ها کجاها به کار برده میشن.


# محتوای فایل های ارلنگ 

در یک فایل حاوی کد ارلنگ ۳ مدل اطلاعات میتونن وجود داشته باشن.

## Comment
کامنت ها در ارلنگ با کاراکتر % شروع میشن و بعد از این کاراکتر تا پایان همون خط هر چی که باشه به عنوان کامنت در نظر گرفته میشه (البته اگه وسط رشته یا string نباشه).

{{< highlight erlang >}}
1> % This is a comment
1>
{{< / highlight >}}

## Attribute
به هر فایل حاوی کد ارلنگ اصطلاحا ماژول یا module گفته میشه. هر ماژول یک سری خصوصیات داره و این خصوصیات رو با attribute ها مشخص میکنیم. برای مثال اگر بخوایم یک ماژول با ویژگی های خاصی کامپایل بشه و توابع مشخصی از این ماژول از بیرون ماژول قابل استفاده باشن و ... .  
سینتکس attribute ها بصورت زیر هست:

{{< highlight erlang >}}
-<NAME>(<PARAMETER-1>, ..., <PARAMETER-n>).
{{< / highlight >}}

نام attribute ها باید اتم باشه و آرگومان هاش میتونن هر چیزی باشن. برای مثال attribute های زیر درست هستن:

{{< highlight erlang >}}
-hello(world).

-attr([1, 2, 3.14]).
{{< / highlight >}}

در واقع attribute ها به دو دسته تقسیم میشن. دسته اول توسط خود ارلنگ مدیریت میشن و دسته دوم که اصطلاحا بهشون user defined attributes میگیم توسط خودمون مدیریت میشن. نکته اول این که ما نمیتونیم از attribute های تحت کنترل ارلنگ در ماژول هامون به هر شکلی خودمون میخوایم استفاده کنیم . نکته دوم هم این که attribute های ما فقط میتونن ۱ آرگومان بگیرن.
در بین attribute های تحت کنترل ارلنگ، وجود attribute با نام module در هر ماژول الزامیه. این attribute یک آرگومان میگیره که همون اسم ماژول بصورت اتم هست.

## Function
طبق قراری که با هم داشتیم خواننده این آموزش حد اقل به یک یا دو زبان برنامه نویسی باید مسلط باشه. بنابر این من اینجا وظیفه تابع رو توضیح نمیدم چون خودتون بلدین و بیشتر به نحوه ی پیاده سازی توابع در ارلنگ میپردازم.  
سینتکس تعریف تابع در فایل بصورت زیر هست:

{{< highlight erlang >}}
<NAME>([<PARAMETER-1>, ..., <PARAMETER-255>) -> <EXPRESION>.
{{< / highlight >}}

در ارلنگ نام های توابع ساختار اتم هستند. البته بهتره از کاراکتر @ در نام توابع استفاده نکنید. هر تابع میتونه هیچ آرگومانی قبول نکنه یا نهایتا ۲۵۵ آرگومان قبول کنه که باید با کاراکتر , یا کاما از هم تفکیک بشن. توابع زیر که در فایل example.erl ذخیره شدن درست هستند

{{< highlight erlang >}}
-module(example).

foo() -> bar.

sum(X, Y) -> X + Y.
{{< / highlight >}}

پترن مچینگ برای آرگومان های توابع هم کار میکنه. برای مثال در تابع sum مقادیری که به عنوان پارامتر بهش میدیم در X و Y ذخیره میشن و در بدنه تابع میتونیم ازشون استفاده کنیم.

# استفاده از کامپایلر
وقتش رسیده ماژولی که نوشتیم رو کامپایل کنیم. برای این کار از دستور erlc که مخفف Erlang Compiler هست استفاده میکنیم:

{{< highlight sh >}}
~ $ erlc example.erl 
example.erl:3: Warning: function foo/0 is unused
example.erl:5: Warning: function sum/2 is unused
{{< / highlight >}}

خوب همونطور که میبینیم کامپایلر در زمان کامپایل ۲ هشدار بهمون داده مبنی بر این که هر دو تابعی که تعریف کردیم استفاده نشدن. اگر بخوام درست تر معنیش کنم، منظورش اینه که یا باید از توابعی که نوشتیم داخل خود ماژول و در بدنه بقیه توابع استفاده کنیم و یا باید به کامپایلر بگیم که قراره این توابع از بیرون ماژول هم قابل استفاده باشن !  
برای این که بتونیم از این توابع از بیرون از ماژول هم استفاده کنیم باید از attribute به نام export استفاده کنیم. این attribute یک لیست شامل نام توابع میگیره و کامپایلر در زمان کامپایل این توابع رو برای دسترسی از خارج از ماژول آزاد میکنه. پس محتویات فایل رو به صورت زیر تغییر میدم:

{{< highlight erlang >}}
-module(example).
-export([foo/0, sum/2]).

foo() -> bar.

sum(X, Y) -> X + Y.
{{< / highlight >}}

باید حواستون باشه که در اینجا منظورمون از foo/0 در واقع تقسیم foo بر 0 نیست. بلکه منظورمون تابعی با نام foo هست که تعداد 0 آرگومان میگیره. حالا چرا باید تعداد آرگومان هارو هم بهش بگیم؟ چون با تشکر از ارلنگ میتونیم تابع دیگه ای با همین نام در همین ماژول داشته باشیم که تعداد آرگومان هاش فرق داشته باشه!

![amazing](/posts/images/erlang-fa.ir-simple-functions-01.jpg)

خوب وقتش رسیده دوباره کامپایل و بعد هم اجراش کنیم:

{{< highlight sh >}}
~ $ erlc example.erl 

~ $ ls *.beam
example.beam
{{< / highlight >}}

همونطور که میبینید کامپایلر خطا یا هشداری نداد و یک فایل جدید با همون اسم اما با پسوند beam در همین دایرکتوری ساخت. این فایل همون فایلی هست که ماشین مجازی ارلنگ برای اجرای کد های ما بهش نیاز داره. فعلا توضیح اضافه تری نمیدم. خوب در همین دایرکتوری یا فولدری که فایل قرار داره شل ارلنگ رو باز میکنیم تا کدمون رو اجرا کنیم. همونطور که گفتم نام ماژول و اسم تابع در ارلنگ اتم هستند. برای اجرای یک تابع از یک ماژول کافیه بین اسم ماژول و اسم تابع کاراکتر : بذاریم و بعد هم آرگومان هایی که لازمه رو بهش بدیم:

{{< highlight erlang >}}
1> example:foo().
bar

2> example:sum(4, 6).
10
{{< / highlight >}}

تبریک!

![congrats](/posts/images/erlang-fa.ir-simple-functions-02.png)

تقریبا هنوز هیچ چیزی از خصوصیات توابع در ارلنگ نگفتم و همچنین راه های دیگه برای اجرای مستقیم و یا کامپایلشون هم وجود داره. ولی کم کم همرو یاد میگیریم. در قسمت بعدی بیشتر از توابع میگم















{{< highlight erlang >}}
{{< / highlight >}}

