+++
title = "شروع‌ به کار"
date = "2019-06-21T00:00:06"
+++



خوب در پست قبلی تا حدودی با ارلنگ آشنا شدیم و قرار شد برای آموزش های بعدی پکیج OTP رو روی سیستممون نصب کنیم. در این قسمت از آموزش قراره یه کم با REPL ارلنگ کار کنیم. واژه REPL مخفف Read-Eval-Print-Loop هست و ماهیت این برنامه اینه که دستورات مارو میخونه و اجرا میکنه و نتایج رو روی صفحه نمایش میده.  

![ready](/posts/images/erlang-fa.ir-give-it-a-try-01.jpg)

برای این کار باید  وارد shell ارلنگ بشیم و برای وارد شدن به shell از دستور erl توی ترمینال استفاده میکنیم:  

{{< highlight sh >}}
$ erl
Erlang/OTP 22 [erts-10.4.4] [source] [64-bit] [smp:4:4] [ds:4:4:10] [async-threads:1] [hipe]

Eshell V10.4.4  (abort with ^G)
1> 
{{< / highlight >}}

وقتی شل رو باز میکنیم یکسری اطلاعات و بعد هم عدد خط رو بهمون نشون میده و بعد هم گوش به فرمان ماست تا هر دستوری که مینویسیم رو اجرا کنه. برای مثال اینجا  از ابتدای خط گفته که این نسخه ۲۲ از OTP هست و همچنین نسخه erts یا Erlang-RunTime-System هم ۱۰.۴.۴ هست. اگر در زمان کامپایل بتونه بفهمه ورژن Git دانلود شده چیه اون رو هم بصورت [source-VERSION] نشون میده و یا فقط [source] رو نشون میده. روی سیستم های 64bit هم یه قسمت [64-bit] به این اطلاعات اضافه میکنه. قسمت های دیگه رو بعدا توضیح میدم. 

همونطور که گفتم الان شل منتظر دستورات ماست تا اجراشون بکنه و نتیجه دستورات رو بهمون نشون بده. قبل از نوشتن هر چیزی بهتره بدونیم که زبان های فانکشنال عبارت-گرا یا Expression-Oriented هستن. معنیش اینه که تو این زبان ها هر عبارت یا Expression یک مقدار خروجی داره. در ارلنگ بعد از هر عبارت باید از نقطه یا . استفاده کنیم:


{{< highlight sh >}}
1> 1.
1

2> 3.14.
3.14

3> 10 + 101010101010101010101010101010101010101010101010101010000
3> 
3> 
3> .
101010101010101010101010101010101010101010101010101010010

4> -1 + 3.
2
{{< / highlight >}}

همونطور که میبینید حتی یک عدد و یا جمع و منهای اعداد هم عبارت هستن و در مورد سوم تا زمانی که نقطه رو تایپ نکردم، خروجی رو بهم نشون نداد.  
همچنین میتونیم یک عبارت شامل چند عبارت داشته باشیم. برای این کار باید عبارات رو با کاما یا , از هم جدا کنیم و بعد از آخرین عبارت نقطه بذاریم. نکته ای که باید یادمون باشه اینه که <bold>خروجی آخرین عبارت از عبارات مرکب به عنوان خروجی کل عبارت در نظر گرفته میشه</bold>:

{{< highlight sh >}}
5> 1+2, 3.14.
3.14

6> 1,
6> 2, 
6> 3,
6> 10 
6> .
10
{{< / highlight >}}

خوب یک سوال مهم اینه که اگر خروجی یک عبارت رو در عبارت بعدی نیاز داشتم و یا میخواستم خوروجی کل عبارت، خروجی یکی از عبارت های اولی باشه چی؟ جوابش متغیر هست:

{{< highlight sh >}}
7> A = 1, 
7> 2 + 3,
7> A.
1
{{< / highlight >}}

فعلا فقط کافیه بدونید در ارلنگ متغیر ها با حروف بزرگ انگلیسی شروع میشن. در ارلنگ از عملگر = برای تطبیق یک الگو یا پترن با یک مقدار استفاده میکنیم. به این کار اصطلاحا pattern matching میگیم.  زمانی که تایپ میکنیم A = 1،  مقدار خروجی عبارت سمت راست عملگر (1) باید قابل تطبیق با الگوی سمت چپ عملگر (A) باشه.  
در این تطبیق الگو، اگر متغییری در سمت چپ وجود داشت که قبلا تعریف نشده بود، تعریف میشه و مقدار نظیر خودش از سمت راست عملگر رو در خودش ذخیره میکنه. همچنین اگر متغیری از قبل تعریف شده باشه و مقدار نظیرش در سمت راست عملگر با مقدار خودش برابر باشه، الگو تطبیق داده میشه. اما اگر متغیری از قبل تعریف شده باشه و مقدار نظیرش در سمت راست عملگر با مقدار خودش یکی نباشه:

{{< highlight sh >}}
8> B = 10.
10

9> B.
10

10> B = 10.
10

11> B = 11.
** exception error: no match of right hand side value 11
{{< / highlight >}}

خطا میده! و داره میگه مقدار سمت راست با مقدار سمت چپ تطبیق داده نشد. چون مقدار سمت چپ عملگر  B یا 10 بود و ما الان داریم میگیم 11 = 10 !  

![wtf](/posts/images/erlang-fa.ir-give-it-a-try-02.png)

مثل ریاضی بهش نگاه کنید. توی عبارات ریاضی وقتی برای مثال مقدار x رو برابر با ۱۰ در نظر میگرفتیم، تا آخر عبارات تغییری نمیکرد.  
الان احتمالا دارین به این فکر میکنین که توی یک پروژه بزرگ، برنامه نویسان ارلنگ چه عذابی میکشن! همش باید حواسشون باشه تو فایل های مختلف اشتباها مقدار یک متغیر رو عوض نکنن! اما باید بگم حدسیاتتون از پایه غلطه و روال کدنویسی توی ارلنگ چه در پروژه کوچیک و چه در پروژه بزرگ اصلا اینطوری  نیست. خواهیم دید که این روش نه تنها باعث سردرگمی و پیچیدگی و سختی نمیشه، بلکه باعث میشه خیلی از خطاهایی که بابت همین تغییر مقدار متغیر بوجود میاد کلا ناپدید بشن. فقط کافیه یه کوچولو صبر کنید تا چند تا ساختمان داده ساده رو یاد بگیریم و آماده نوشتن توابع ساده بشیم.
















{{< highlight sh >}}
{{< / highlight >}}
